@use "sass:map";
@use "sass:color";
@use "sass:string";
@use "sass:meta";
@use "sass:list";
@use "sass:math";
@use "../config" as *;
@use "../tokens" as *;

/*
 * ================ Funciones ================
 */

/*
 * Transforma un valor en hexadecimal en los tres valores que forman un color rgb
 *
 * @param {string} $hexColor - Color en formato hexadecimal
 * @return {string} - Valores del color en rgb
 *
 * @example SCSS
 *   hex2rgb(#8f0537) =>  221,34,78;
 */

@function hex2rgb($hexColor) {
  @if meta.type-of($hexColor) != color {
    @error "hex2rgb() expects a color value, received #{meta.type-of($hexColor)}: #{$hexColor}";
  }

  @return "#{color.channel($hexColor, "red", $space: rgb)},#{color.channel($hexColor, "green", $space: rgb)},#{color.channel($hexColor, "blue", $space: rgb)}";
}

/*
 * Codifica un color para poder para poderlo usar dentro de un string
 *
 * @param {string} $color - Color en formato hexadecimal o el nombre de un color definido en la configuración
 * @return {string} - Color codificado
 *
 * @example SCSS
 *   encodecolor(#8f0537) => %238f0537;
 *   encodecolor(brand)   => %238f0537;
 */

@function encodecolor($color) {
  $resolved-color: null;

  @if meta.type-of($color) == color {
    $resolved-color: $color;
  } @else if meta.type-of($color) == string {
    $primary-theme-colors: map.get($themes, $primary-theme);

    @if map.has-key($primary-theme-colors, $color) {
      $resolved-color: map.get($primary-theme-colors, $color);
    } @else {
      $available-colors: map.keys($primary-theme-colors);
      @error "encodecolor(): Color token '#{$color}' not found. Available tokens: #{$available-colors}";
    }
  } @else {
    @error "encodecolor() expects a color token (string) or hex value (color), received #{meta.type-of($color)}: #{$color}";
  }

  $hex: string.slice(color.ie-hex-str($resolved-color), 4);
  $color: string.unquote("#{$hex}");
  @return "%23" + $color;
}

/*
 * Devuelve el color y opacidad indicados en formato rgba.
 * Ahora con soporte para herencia de temas desde primary-theme
 *
 * @param {string} $color - Nombre del color del tema o color en hexadecimal
 * @param {number} $opacity - Valor de la Opacidad de 0 a 1
 * @param {string} $theme - Tema específico (opcional, usa primary por defecto)
 * @return {string} - Color en formato rgba
 */

@function color($color, $opacity: 1, $theme: null) {
  @if meta.type-of($opacity) == number and ($opacity < 0 or $opacity > 1) {
    @error "La opacidad debe tener un valor entre 0 y 1";
  }

  // Si es un color hexadecimal directo
  @if meta.type-of($color) == color {
    @return rgba($color, $opacity);
  }

  // Usar tema específico o primary-theme por defecto
  $target-theme: $theme or $primary-theme;
  $themes-map: map.get($tokens, themes);

  // Buscar color en tema específico
  @if map.has-key($themes-map, $target-theme) {
    $theme-colors: map.get($themes-map, $target-theme);

    @if map.has-key($theme-colors, $color) {
      $color-value: map.get($theme-colors, $color);

      // Si el color tiene estructura (value, abbr)
      @if meta.type-of($color-value) == "map" {
        $color-value: map.get($color-value, value);
      }

      @if $css-variables == true {
        @return rgba(var(--#{$color}), $opacity);
      }
      @return rgba($color-value, $opacity);
    }
  }

  // Si no existe en tema específico, buscar en primary theme
  @if $target-theme != $primary-theme {
    $primary-colors: map.get($themes-map, $primary-theme);

    @if map.has-key($primary-colors, $color) {
      $color-value: map.get($primary-colors, $color);

      // Si el color tiene estructura (value, abbr)
      @if meta.type-of($color-value) == "map" {
        $color-value: map.get($color-value, value);
      }

      @if $css-variables == true {
        @return rgba(var(--#{$color}), $opacity);
      }
      @return rgba($color-value, $opacity);
    }
  }

  @error "Color '#{$color}' not found in theme '#{$target-theme}' or primary theme '#{$primary-theme}'";
}

/*
 * ================ Mixins ================
 */

/*
 * Genera una variación específica para un tema
 * por defecto se crean los temas 'light', 'dark' aunque se pueden crear nuevos
 *
 * @param {String} $theme - Indica el tema al que aplica
 *
 * @example SCSS
 *   .myClass {
 *     @include theme(dark) {
 *       color: color(brand);
 *     }
 *   }
 *
 * @result CSS
 *   .myClass [data-theme=dark] {
 *     color: rgba(var(--brand), 1);
 *   }
 */

@mixin theme($theme) {
  @if meta.type-of($theme) != string {
    @error "theme() mixin expects a theme name (string), received #{meta.type-of($theme)}: #{$theme}";
  }

  [data-theme="#{$theme}"] {
    @content;
  }
}

/*
 * ================ Gradient Functions ================
 */

/*
 * Returns a gradient between two colors with the specified type
 *
 * @param {string} $color1 - Gradient name defined in global config, or start color in hex
 * @param {string} $color2 - End color in hex
 * @param {string} $type - Gradient type [linear, radial, conic]
 * @param {string} $direction - Gradient direction
 * @result {string} - Gradient
 *
 * @example SCSS
 *   gradient(brand) => radial-gradient(ellipse at left top, rgba(var(--brand-light, 1) 0%, rgba(var(--brand-dark), 1) 100%)
 *   gradient(brand) => radial-gradient(ellipse at left top, rgba(251,80,103, 1) 0%, rgba(187,22,66, 1) 100%)
 *   gradient(brand), linear => linear-gradient(from 90deg at 50% 50%, rgba(var(--brand-light, 1) 0%, rgba(var(--brand-dark), 1) 100%)
 */

@function gradient($color1, $color2: null, $type: $gradient-default, $direction: "to bottom") {
  @if not list.index((linear, radial, conic), $type) {
    @error "Gradient type doesn't exist, only accepts linear, radial or conic";
  }

  @if map.has-key($gradients, $color1) {
    $colors: map.get($gradients, $color1);
    $color1: list.nth($colors, 1);
    $color2: list.nth($colors, 2);
  }

  @if meta.type-of($color1) != color {
    $color1: color($color1);
  }

  @if meta.type-of($color2) != color {
    $color2: color($color2);
  }

  @if $type == radial {
    @return radial-gradient(ellipse at left top, $color1 0%, $color2 100%);
  }

  @if $type == conic {
    @return conic-gradient(from 90deg at 50% 50%, $color1 0%, $color2 100%);
  }

  @return linear-gradient(#{$direction}, $color1 0%, $color2 100%);
}

/*
 * Returns a softened gradient from a color to transparent
 *
 * @param {String} $color - Shadow color in hex or predefined color name
 * @param {Number} $opacity - Maximum gradient opacity
 * @param {String} $direction - Gradient direction, in text format or deg/rad
 *
 * @example SCSS
 *   scrim-gradient() => linear-gradient(
 *                         to top,
 *                         rgba(var(--shadow-color), 0.9) 0%,
 *                         rgba(var(--shadow-color), 0.6642) 19%,
 *                         rgba(var(--shadow-color), 0.4869) 34%,
 *                         rgba(var(--shadow-color), 0.3438) 47%,
 *                         rgba(var(--shadow-color), 0.2502) 56.5%,
 *                         rgba(var(--shadow-color), 0.1746) 65%,
 *                         rgba(var(--shadow-color), 0.1134) 73%,
 *                         rgba(var(--shadow-color), 0.0675) 80.2%,
 *                         rgba(var(--shadow-color), 0.0378) 86.1%,
 *                         rgba(var(--shadow-color), 0.0189) 91%,
 *                         rgba(var(--shadow-color), 0.0072) 95.2%,
 *                         rgba(var(--shadow-color), 0.0018) 98.2%,
 *                         rgba(var(--shadow-color), 0) 100%)
 */

@function scrim-gradient($color: $shadow-color, $opacity: 0.9, $direction: "to top") {
  $scrim: (
    1: 0%,
    0.738: 19%,
    0.541: 34%,
    0.382: 47%,
    0.278: 56.5%,
    0.194: 65%,
    0.126: 73%,
    0.075: 80.2%,
    0.042: 86.1%,
    0.021: 91%,
    0.008: 95.2%,
    0.002: 98.2%,
    0: 100%,
  );

  @if is-direction($direction) == false {
    @error "#{$direction} is not a valid direction";
  }

  @if $opacity < 0 or $opacity > 1 {
    @error "#{$opacity} must be a value between 0 and 1";
  }

  $color-stops: ();

  @each $key, $value in $scrim {
    @if $css-variables == true and $color == $shadow-color {
      $color-stops: list.append(
        $color-stops,
        string.unquote("rgba(var(--shadow-color), #{$key * $opacity}) #{$value}"),
        "comma"
      );
    } @else {
      $color-stops: list.append(
        $color-stops,
        string.unquote("#{color($color, $key * $opacity)} #{$value}"),
        "comma"
      );
    }
  }

  @return linear-gradient(string.unquote($direction), #{$color-stops});
}

/*
 * ================ Gradient Mixins ================
 */

/*
 * Generates a gradient with the specified colors and type for text
 *
 * @param {string} $color1 - Gradient name defined in global config, or start color in hex
 * @param {string} $color2 - End color in hex
 * @param {string} $type - Gradient type [linear, radial, conic]
 *
 * @example SCSS
 *     .myClass {
 *       @include text-gradient(brand);
 *     }
 *
 * @result CSS
 *     .myClass {
 *       background-image: radial-gradient(ellipse at left top, rgba(var(--brand-lighter), 1) 0%, rgba(var(--brand-darker), 1) 100%);
 *       color: transparent;
 *       -webkit-background-clip: text;
 *       background-clip: text;
 *     }
 */
@mixin text-gradient($color1, $color2: null, $type: $gradient-default, $direction: "to right") {
  color: transparent;
  background: gradient($color1, $color2, $type, $direction);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

/*
 * Generates a gradient with the specified colors and type for borders
 * for elements with transparent background and radius
 *
 * @param {string} $color1 - Gradient name defined in global config, or start color in hex
 * @param {string} $color2 - End color in hex
 * @param {string} $type - Gradient type [linear, radial, conic]
 * @param {string} $radius - Border radius at corners
 * @param {string} $width - Border width
 *
 * @example SCSS
 *     .myClass {
 *       @include border-gradient(brand-light, brand-dark, radial, 10px, 2px);
 *     }
 *
 * @result CSS
 *     .myClass {
 *       background-origin: border-box;
 *       background-clip: content-box, border-box;
 *       background: url('data:image/svg+xml;utf8, <svg xmlns="http: *www.w3.org/2000/svg"><defs><radialGradient id="Gradient" cx="0" cy="0" r="150%"><stop stop-color="%23FB5067" offset="0%"/><stop stop-color="%23BB1642" offset="100%"/></radialGradient></defs><rect x="1px" y="1px" width="100%" height="100%" style="height:calc(100% - 2px); width:calc(100% - 2px)" rx="10px" ry="10px" stroke-width="2px" fill="transparent" stroke="url(%23Gradient)"/></svg>');
 *     }
 */

@mixin border-gradient(
  $color1,
  $color2: null,
  $type: $gradient-default,
  $radius: 10px,
  $width: 2px
) {
  @if not list.index((linear, radial, conic), $type) {
    @error "Gradient type doesn't exist, only accepts linear, radial or conic";
  }

  @if map.has-key($gradients, $color1) {
    $colors: map.get($gradients, $color1);
    $color1: list.nth($colors, 1);
    $color2: list.nth($colors, 2);
  }

  // For border gradient we need real colors, not CSS variables
  $primary-theme-colors: map.get($themes, $primary-theme);

  @if meta.type-of($color1) != color {
    @if map.get($primary-theme-colors, $color1) {
      $color1: map.get($primary-theme-colors, $color1);
    }
  }

  @if meta.type-of($color2) != color {
    @if map.get($primary-theme-colors, $color2) {
      $color2: map.get($primary-theme-colors, $color2);
    }
  }

  // Use border-image for gradient borders
  border: #{$width} solid;
  border-radius: $radius;
  border-image: gradient($color1, $color2, $type) 1;
}
