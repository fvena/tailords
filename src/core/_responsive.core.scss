@use "sass:map";
@use "../variables" as *;
@use "math.core" as *;

/*
 * ================ Responsive System ================
 *
 * Uses user-defined breakpoints from variables to generate media queries.
 * No hardcoded values - everything comes from user configuration via _variables.scss.
 */

/*
 * Generate responsive media queries from user tokens
 * Creates mobile-first approach with max-width boundaries
 */
@function generate-media-queries($breakpoints) {
  $media-queries: ();
  $breakpoint-names: map.keys($breakpoints);
  $sorted-breakpoints: ();

  // Sort breakpoints by value for proper media query generation
  @each $name, $value in $breakpoints {
    $sorted-breakpoints: map.merge(
      $sorted-breakpoints,
      (
        $value: $name,
      )
    );
  }

  $prev-breakpoint: 0;
  $breakpoint-values: map.keys($sorted-breakpoints);

  @for $i from 1 through length($breakpoint-values) {
    $current-value: nth($breakpoint-values, $i);
    $current-name: map.get($sorted-breakpoints, $current-value);

    @if $i == 1 {
      // First breakpoint: mobile-first (max-width only)
      $media-queries: map.merge(
        $media-queries,
        (
          $current-name: "screen and (max-width: #{pxToEm($current-value - 1)})",
        )
      );
    } @else if $i == length($breakpoint-values) {
      // Last breakpoint: desktop (min-width only)
      $media-queries: map.merge(
        $media-queries,
        (
          $current-name: "screen and (min-width: #{pxToEm($prev-breakpoint)})",
        )
      );
    } @else {
      // Middle breakpoints: min and max width
      $media-queries: map.merge(
        $media-queries,
        (
          $current-name:
            "screen and (min-width: #{pxToEm($prev-breakpoint)}) and (max-width: #{pxToEm($current-value - 1)})",
        )
      );
    }

    $prev-breakpoint: $current-value;
  }

  // Add semantic aliases based on breakpoint count
  @if length($breakpoint-values) >= 2 {
    $first-name: map.get($sorted-breakpoints, nth($breakpoint-values, 1));
    $last-name: map.get($sorted-breakpoints, nth($breakpoint-values, length($breakpoint-values)));

    $media-queries: map.merge(
      $media-queries,
      (
        "mobile": map.get($media-queries, $first-name),
        "desktop": map.get($media-queries, $last-name),
      )
    );
  }

  @if length($breakpoint-values) >= 3 {
    $second-name: map.get($sorted-breakpoints, nth($breakpoint-values, 2));
    $media-queries: map.merge(
      $media-queries,
      (
        "tablet": map.get($media-queries, $second-name),
      )
    );
  }

  // Add orientation and device type aliases
  $media-queries: map.merge(
    $media-queries,
    (
      "portrait": "screen and (orientation: portrait)",
      "landscape": "screen and (orientation: landscape)",
      "touch": "screen and (hover: none) and (pointer: coarse)",
      "no-touch": "screen and (hover: hover) and (pointer: fine)",
    )
  );

  @return $media-queries;
}

/*
 * Generated media queries from user breakpoints (extracted in _variables.scss)
 */
$responsive-media-queries: generate-media-queries($breakpoints);

/*
 * ================ Mixins ================
 */

/*
 * Genera una clase con todas sus variantes responsive
 * Uses user-defined breakpoints from configuration
 *
 * @example SCSS
 *     .myClass {
 *       @include responsive {
 *         color: color(brand);
 *       }
 *     }
 *
 * @result CSS (assuming user has palm: 600px, desk: 1200px)
 *      .myClass {
 *        color: rgba(var(--brand), 1);
 *      }
 *
 *      @media screen and (max-width: 37.4375em) {
 *        .myClass--palm {
 *          color: rgba(var(--brand), 1);
 *        }
 *      }
 *
 *      @media screen and (min-width: 75em) {
 *        .myClass--desk {
 *          color: rgba(var(--brand), 1);
 *        }
 *      }
 */
@mixin responsive {
  @content;

  @if map.get($utilities, config, responsive) == true {
    @each $breakpoint-name in $responsive-breakpoints {
      @if map.has-key($responsive-media-queries, $breakpoint-name) {
        @media #{map.get($responsive-media-queries, $breakpoint-name)} {
          &--#{$breakpoint-name} {
            @content;
          }
        }
      } @else {
        @warn "Breakpoint '#{$breakpoint-name}' not found in user breakpoints. Available: #{map.keys($breakpoints)}";
      }
    }
  }
}

/*
 * Genera un media query con los par√°metros del tipo de pantalla seleccionada
 * Uses user-defined breakpoints and semantic aliases
 *
 * @param {String} $breakpoint - Breakpoint name from user configuration or semantic alias
 *
 * @example SCSS
 *     .myClass {
 *       @include media(palm) {  // User-defined breakpoint
 *         color: color(brand);
 *       }
 *
 *       @include media(mobile) {  // Semantic alias
 *         font-size: font(small1);
 *       }
 *     }
 *
 * @result CSS
 *     @media screen and (max-width: 37.4375em) {
 *       .myClass {
 *         color: rgba(var(--brand), 1);
 *         font-size: 0.85rem;
 *       }
 *     }
 */
@mixin media($breakpoint) {
  @if map.has-key($responsive-media-queries, $breakpoint) {
    @media #{map.get($responsive-media-queries, $breakpoint)} {
      @content;
    }
  } @else if $breakpoint == "notch" {
    // Special case for devices with notch
    @supports (padding: max(0)) and (padding: env(safe-area-inset-bottom)) {
      @content;
    }
  } @else if $breakpoint == "all" {
    // Special case for all screen sizes
    @content;
  } @else {
    $available-breakpoints: map.keys($responsive-media-queries);
    @warn "Breakpoint '#{$breakpoint}' not found. Available breakpoints: #{$available-breakpoints}";
  }
}
